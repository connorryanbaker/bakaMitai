package board

type Board struct {
	pieces       [120]int
	castle       [4]bool // wck,wcq,bck,bcq
	ep           *int
	side         int
	hply         int
	ply          int
	pieceSquares map[int][]int
}

// todo:
// makemove [ ]
// - update existing fields in state
// - return false if illegal position
// track move history [ ]
// add move hash to history for position comparison [ ]
// printing for debugging / ui [ ]
// https://www.chessprogramming.org/Zobrist_Hashing
// fifty move rule
// recognize checkmate, stalemate
// move history: boardstate struct w/ hash, castling, ep, move, incheck?, repetitions
// make move fn to maintain all this state
// unmake move fn

func NewBoard() Board {
	return Board{
		INIT_PIECES,
		INIT_CASTLE,
		nil,
		WHITE,
		0,
		0,
		INIT_PIECE_SQUARES, // we'll see if this works
	}
}

// again - let's just get something going
// if legal move, update internal state and return true
// otherwise, return false and maintain current state
func (b *Board) MakeMove(m Move) bool { // should this return (bool, Board) w/ a copy
	// regarding validation
	// current thought is to validate moves when accepting user input
	// otherwise assume that moves generated by board are semi-valid
	// illegal moves (that leave king in check) will be undone by make move

	movingPiece := b.PieceAt(m.from)
	if b.PieceColor(movingPiece) != b.side {
		return false
	}

	if m.castleKingside {
		b.castleKingside(m)
		return true
	}

	if m.castleQueenside {
		b.castleQueenside(m)
		return true
	}

	if m.promote {
		return b.handlePromotion(m)
	}

	if m.capture && (movingPiece == WHITE_PAWN || movingPiece == BLACK_PAWN) && m.to == *b.ep {
		return b.handleEPCapture(m)
	}

	if m.capture {
		return b.handleCapture(m)
	}

	pieceAtDestSq := b.PieceAt(m.to)
	b.pieces[m.to] = movingPiece
	b.pieces[m.from] = EMPTY_SQUARE
	if b.InCheck(b.side) {
		b.pieces[m.from] = movingPiece
		b.pieces[m.to] = pieceAtDestSq
		return false
	}

	if m.doublePawnPush {
		if b.side == WHITE {
			s := m.to + 10
			b.ep = &s
		} else {
			s := m.to - 10
			b.ep = &s
		}
	}

	b.updateCastlePermissions(m, movingPiece)
	if movingPiece == WHITE_PAWN || movingPiece == BLACK_PAWN {
		b.hply = 0
	} else {
		b.hply += 1
	}
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
	return true
}

func (b *Board) handleCapture(m Move) bool {
	movingPiece := b.PieceAt(m.from)
	capturedPiece := b.PieceAt(m.to)
	b.pieces[m.to] = movingPiece
	b.pieces[m.from] = EMPTY_SQUARE
	b.updatePieceSquares()
	if b.InCheck(b.side) {
		b.pieces[m.to] = capturedPiece
		b.pieces[m.from] = movingPiece
		b.updatePieceSquares()
		return false
	}
	b.updateCastlePermissions(m, movingPiece)
	b.ep = nil
	b.hply = 0
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
	return true
}

func (b *Board) handlePromotion(m Move) bool {
	prevSq := b.PieceAt(m.to)
	movingPiece := b.PieceAt(m.from)
	b.pieces[m.to] = m.promotionPiece
	b.pieces[m.from] = EMPTY_SQUARE
	b.updatePieceSquares()
	if b.InCheck(b.side) {
		b.pieces[m.to] = prevSq
		b.pieces[m.from] = movingPiece
		b.updatePieceSquares()
		return false
	}
	b.ep = nil
	b.hply = 0
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
	return true
}

func (b *Board) updateCastlePermissions(m Move, p int) {
	if b.side == WHITE {
		if !b.castle[0] && !b.castle[1] {
			return
		}
		if p != WHITE_ROOK && p != WHITE_KING {
			return
		}
		if p == WHITE_KING {
			b.castle[0] = false
			b.castle[1] = false
			return
		}
		if m.from == IA1 {
			b.castle[1] = false
			return
		}
		if m.from == IH1 {
			b.castle[0] = false
		}
	} else {
		if !b.castle[2] && !b.castle[3] {
			return
		}
		if p != BLACK_ROOK && p != BLACK_KING {
			return
		}
		if p == BLACK_KING {
			b.castle[2] = false
			b.castle[3] = false
			return
		}
		if m.from == IA8 {
			b.castle[3] = false
			return
		}
		if m.from == IH8 {
			b.castle[2] = false
		}
	}
}

func (b *Board) handleEPCapture(m Move) bool {
	if b.side == WHITE {
		b.pieces[m.to] = WHITE_PAWN
		b.pieces[m.from] = EMPTY_SQUARE
		b.pieces[m.to+10] = EMPTY_SQUARE
		b.updatePieceSquares()
		if b.InCheck(b.side) {
			b.pieces[m.to+10] = BLACK_PAWN
			b.pieces[m.to] = EMPTY_SQUARE
			b.pieces[m.from] = WHITE_PAWN
			b.updatePieceSquares()
			return false
		}
	} else {
		b.pieces[m.to] = BLACK_PAWN
		b.pieces[m.from] = EMPTY_SQUARE
		b.pieces[m.to-10] = EMPTY_SQUARE
		b.updatePieceSquares()
		if b.InCheck(b.side) {
			b.pieces[m.to-10] = WHITE_PAWN
			b.pieces[m.to] = EMPTY_SQUARE
			b.pieces[m.from] = BLACK_PAWN
			b.updatePieceSquares()
			return false
		}
	}
	b.hply = 0
	b.ep = nil
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
	return true
}

func (b *Board) castleKingside(m Move) {
	if b.side == WHITE {
		b.pieces[IG1] = WHITE_KING
		b.pieces[IF1] = WHITE_ROOK
		b.pieces[IE1] = EMPTY_SQUARE
		b.pieces[IH1] = EMPTY_SQUARE
		b.castle[0] = false
		b.castle[1] = false
	} else {
		b.pieces[IG8] = BLACK_KING
		b.pieces[IF8] = BLACK_ROOK
		b.pieces[IE8] = EMPTY_SQUARE
		b.pieces[IH8] = EMPTY_SQUARE
		b.castle[2] = false
		b.castle[3] = false
	}
	b.updatePieceSquares()
	b.ep = nil
	b.hply += 1
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
}

func (b *Board) castleQueenside(m Move) {
	if b.side == WHITE {
		b.pieces[IC1] = WHITE_KING
		b.pieces[ID1] = WHITE_ROOK
		b.pieces[IE1] = EMPTY_SQUARE
		b.pieces[IA1] = EMPTY_SQUARE
		b.castle[0] = false
		b.castle[1] = false
	} else {
		b.pieces[IC8] = BLACK_KING
		b.pieces[ID8] = BLACK_ROOK
		b.pieces[IE8] = EMPTY_SQUARE
		b.pieces[IA8] = EMPTY_SQUARE
		b.castle[2] = false
		b.castle[3] = false
	}
	b.updatePieceSquares()
	b.ep = nil
	b.hply += 1
	if b.side == BLACK {
		b.ply += 1
	}
	b.side ^= 1
}

func (b Board) PieceColor(p int) int {
	// todo: return error if invalid, error handling
	if EMPTY_SQUARE < p && p < BLACK_PAWN {
		return WHITE
	}
	return BLACK
}

func (b Board) PieceAt(idx int) int {
	return b.pieces[idx]
}

func (b Board) InCheck(side int) bool {
	if side == WHITE {
		kingPos := b.pieceSquares[WHITE_KING][0]
		attackedSquares := toLookupMap(b.SquaresAttackedByBlackPieces())
		return attackedSquares[kingPos] == true
	}

	kingPos := b.pieceSquares[BLACK_KING][0]
	attackedSquares := toLookupMap(b.SquaresAttackedByWhitePieces())
	return attackedSquares[kingPos] == true
}

func (b *Board) updatePieceSquares() {
	nps := make(map[int][]int)
	for i := 0; i < 64; i++ {
		idx := MAILBOX_64[i]
		if b.pieces[idx] == EMPTY_SQUARE {
			continue
		}

		p := b.pieces[idx]
		if nps[p] != nil {
			nps[p] = append(nps[p], idx)
		} else {
			nps[p] = make([]int, 1)
			nps[p][0] = idx
		}
	}
	b.pieceSquares = nps
}

func emptyPiecesArray() [120]int {
	p := [120]int{}
	for i := 0; i < 120; i++ {
		p[i] = OFF_BOARD
	}
	for i := 0; i < 64; i++ {
		p[MAILBOX_64[i]] = EMPTY_SQUARE
	}
	return p
}
