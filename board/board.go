package board

type Board struct {
	pieces       [120]int
	castle       [4]bool // wck,wcq,bck,bcq
	ep           *int
	side         int
	hply         int
	ply          int
	pieceSquares map[int][]int
	// todo:
	// makemove [ ]
	// - update existing fields in state
	// - return false if illegal position
	// track move history [ ]
	// add move hash to history for position comparison [ ]
	// printing for debugging / ui [ ]
	// https://www.chessprogramming.org/Zobrist_Hashing
	// fifty move rule
	// recognize checkmate, stalemate
	// move history: boardstate struct w/ hash, castling, ep, move, incheck?, repetitions
	// make move fn to maintain all this state
	// unmake move fn
}

func NewBoard() Board {
	return Board{
		INIT_PIECES,
		INIT_CASTLE,
		nil,
		WHITE,
		0,
		0,
		INIT_PIECE_SQUARES, // we'll see if this works
	}
}

// again - let's just get something going
// if legal move, update internal state and return true
// otherwise, return false and maintain current state
func (b Board) MakeMove(m Move) bool { // should this return (bool, Board) w/ a copy
	// regarding validation
	// current thought is to validate moves when accepting user input
	// otherwise assume that moves generated by board are semi-valid
	// illegal moves (that leave king in check) will be undone by make move
	// update pieces
	// if in check, undo and return false
	// otherwise update castle, ep, hply, ply and pieceSquares

	movingPiece := b.PieceAt(m.from)
	if b.PieceColor(movingPiece) != b.side {
		return false
	}
	// this is just for simple cases
	// need to handle castling, ep, promotion
	if m.castleKingside {
		return b.castleKingside(m)
	}

	// this is 'typical' case
	pieceAtDestSq := b.PieceAt(m.to)
	b.pieces[m.to] = movingPiece
	b.pieces[m.from] = EMPTY_SQUARE
	if b.InCheck(b.side) {
		b.pieces[m.from] = movingPiece
		b.pieces[m.to] = pieceAtDestSq
		return false
	}
}

func (b Board) castleKingside(m Move) bool {
	if b.side == WHITE {
		b.pieces[IG1] = WHITE_KING
		b.pieces[IF1] = WHITE_ROOK
		b.pieces[IE1] = EMPTY_SQUARE
		b.pieces[IH1] = EMPTY_SQUARE
		b.castle[0] = false
		b.castle[1] = false
		b.pieceSquares[WHITE_KING][0] = IG1
		for i, sq := range b.pieceSquares[WHITE_ROOK] {
			if sq == IH1 {
				b.pieceSquares[WHITE_ROOK][i] = IF1
			}
		}
	} else {
		b.pieces[IG8] = WHITE_KING
		b.pieces[IF8] = WHITE_ROOK
		b.pieces[IE8] = EMPTY_SQUARE
		b.pieces[IH8] = EMPTY_SQUARE
		b.castle[2] = false
		b.castle[3] = false
		b.pieceSquares[BLACK_KING][0] = IG8
		for i, sq := range b.pieceSquares[BLACK_ROOK] {
			if sq == IH8 {
				b.pieceSquares[BLACK_ROOK][i] = IF8
			}
		}
	}
	return true
}

func (b Board) PieceColor(p int) int {
	// todo: this obviously could use improvement
	// return error if invalid, error handling
	if EMPTY_SQUARE < p && p < BLACK_PAWN {
		return WHITE
	}
	return BLACK
}

func (b Board) PieceAt(idx int) int {
	return b.pieces[idx]
}

// this could / should(?) use side struct field
// taking param now for easier testing
func (b Board) InCheck(side int) bool {
	if side == WHITE {
		kingPos := b.pieceSquares[WHITE_KING][0]
		attackedSquares := toLookupMap(b.SquaresAttackedByBlackPieces())
		return attackedSquares[kingPos] == true
	}

	kingPos := b.pieceSquares[BLACK_KING][0]
	attackedSquares := toLookupMap(b.SquaresAttackedByWhitePieces())
	return attackedSquares[kingPos] == true
}

func emptyPiecesArray() [120]int {
	p := [120]int{}
	for i := 0; i < 120; i++ {
		p[i] = OFF_BOARD
	}
	for i := 0; i < 64; i++ {
		p[MAILBOX_64[i]] = EMPTY_SQUARE
	}
	return p
}
